<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>iPRD Deploy Console</title>
  <style>
    :root {
      --bg: #F8FAFC;
      --text: #1E293B;
      --muted: #475569;
      --border: #E2E8F0;
      --card: #FFFFFF;
      --brand: #00E5FF;
      --brand-2: #14B8A6;
      --warn: #F59E0B;
      --bad: #E11D48;
      --ok: #0F766E;
      --shadow: 0 16px 40px rgba(2, 6, 23, 0.08);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: "Inter Tight", "Inter", "Segoe UI", sans-serif;
    }

    body {
      overflow: hidden;
      background-image:
        radial-gradient(circle at 8% 8%, rgba(0, 229, 255, 0.08), transparent 42%),
        radial-gradient(circle at 92% 12%, rgba(20, 184, 166, 0.08), transparent 36%),
        linear-gradient(160deg, #F8FAFC 0%, #EDF3F8 52%, #EAF1F5 100%);
    }

    .shell {
      height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 20;
      backdrop-filter: blur(8px);
      background: rgba(248, 250, 252, 0.92);
      border-bottom: 1px solid var(--border);
      padding: 14px 20px;
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.7) inset;
    }

    .header h1 {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .tip {
      margin-top: 4px;
      color: var(--muted);
      font-size: 13px;
    }

    .main {
      margin-top: 78px;
      margin-bottom: 52px;
      padding: 16px;
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
      height: calc(100vh - 130px);
      overflow: hidden;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 16px;
      background: var(--card);
      box-shadow: var(--shadow);
      overflow: auto;
      padding: 14px;
    }

    .section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fff;
    }

    .section-title {
      margin: 0 0 10px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      font-weight: 700;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px;
      font-size: 14px;
    }

    textarea {
      min-height: 180px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      line-height: 1.5;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    button {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      color: var(--text);
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
    }

    .primary {
      color: #00131a;
      border-color: transparent;
      background: linear-gradient(135deg, var(--brand), var(--brand-2));
    }

    .ghost {
      background: #f8fafc;
    }

    .status {
      margin-top: 8px;
      border: 1px dashed var(--border);
      border-radius: 10px;
      padding: 10px;
      color: var(--muted);
      font-size: 13px;
      white-space: pre-wrap;
      line-height: 1.45;
    }

    .status.ok { border-color: #99f6e4; color: var(--ok); background: #f0fdfa; }
    .status.warn { border-color: #fde68a; color: #92400e; background: #fffbeb; }
    .status.bad { border-color: #fecdd3; color: #9f1239; background: #fff1f2; }

    .cards {
      display: grid;
      gap: 8px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
      align-items: center;
    }

    .card a {
      color: #0F172A;
      text-decoration: none;
      font-weight: 700;
    }

    .card small {
      display: block;
      color: var(--muted);
      margin-top: 2px;
    }

    .preview-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }

    .badge {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 9px;
      background: #f8fafc;
    }

    iframe {
      width: 100%;
      min-height: 460px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
    }

    .checks {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: #fcfdff;
    }

    .check-item {
      display: flex;
      gap: 8px;
      align-items: baseline;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .check-item b { color: var(--text); }

    .footer {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 52px;
      border-top: 1px solid var(--border);
      background: rgba(248, 250, 252, 0.96);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 13px;
      backdrop-filter: blur(6px);
    }

    @media (max-width: 980px) {
      body { overflow: auto; }
      .main {
        grid-template-columns: 1fr;
        height: auto;
        min-height: calc(100vh - 130px);
      }
      .panel { min-height: 560px; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header class="header">
      <h1>Interactive iPRD</h1>
      <div class="tip">Tip: Use Canvas Preview to interact.</div>
    </header>

    <main class="main">
      <section class="panel">
        <div class="section">
          <h2 class="section-title">Hosted PRDs</h2>
          <div class="btn-row" style="margin-top:0;">
            <button id="refreshRegistry" class="ghost">Refresh List</button>
          </div>
          <div id="cards" class="cards" style="margin-top:10px;"></div>
        </div>

        <div class="section">
          <h2 class="section-title">Deploy Payload</h2>
          <label for="htmlFile">Upload generated HTML</label>
          <input id="htmlFile" type="file" accept=".html,text/html" />

          <div style="height:10px;"></div>
          <label for="htmlInput">Or paste generated index.html</label>
          <textarea id="htmlInput" placeholder="Paste complete HTML here..."></textarea>

          <div style="height:10px;"></div>
          <div class="row">
            <div>
              <label for="slug">Slug</label>
              <input id="slug" type="text" placeholder="AI-index" />
            </div>
            <div>
              <label for="title">Display Title</label>
              <input id="title" type="text" placeholder="AI Features" />
            </div>
          </div>
        </div>

        <div class="section">
          <h2 class="section-title">Authentication</h2>
          <label for="token">GitHub Fine-Grained PAT</label>
          <input id="token" type="password" placeholder="Bearer token (Actions + Contents write)" />
          <div class="btn-row">
            <button id="saveToken" class="ghost">Save Token</button>
            <button id="clearToken" class="ghost">Clear Token</button>
          </div>
          <div id="status" class="status">Ready. Load HTML, then preview and deploy.</div>

          <div class="btn-row">
            <button id="validateBtn">Validate HTML</button>
            <button id="previewBtn">Preview</button>
            <button id="deployBtn" class="primary">Deploy as GitHub Page</button>
            <button id="checkRunBtn" class="ghost">Check Latest Run</button>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="preview-head">
          <h2 class="section-title" style="margin:0;">Preview</h2>
          <span id="surfaceTag" class="badge">No HTML loaded</span>
        </div>
        <iframe id="preview"></iframe>

        <div class="checks" id="checks"></div>
      </section>
    </main>

    <footer class="footer">Made with ❤️ & ☕ by RBX Labs</footer>
  </div>

  <script>
    const REPO_OWNER = "RBX-Labs";
    const REPO_NAME = "iPRD";
    const WORKFLOW_FILE = "publish-iprd.yml";
    const WORKFLOW_INPUT_LIMIT = 65535;

    const fileInput = document.getElementById("htmlFile");
    const htmlInput = document.getElementById("htmlInput");
    const slugInput = document.getElementById("slug");
    const titleInput = document.getElementById("title");
    const tokenInput = document.getElementById("token");
    const statusBox = document.getElementById("status");
    const previewFrame = document.getElementById("preview");
    const cards = document.getElementById("cards");
    const checks = document.getElementById("checks");
    const surfaceTag = document.getElementById("surfaceTag");

    function slugify(raw) {
      return raw
        .trim()
        .replace(/\.html?$/i, "")
        .replace(/\s+/g, "-")
        .replace(/[^A-Za-z0-9-]/g, "")
        .replace(/-+/g, "-");
    }

    function toB64(str) {
      return btoa(unescape(encodeURIComponent(str)));
    }

    function toUtf8Bytes(str) {
      return new TextEncoder().encode(str);
    }

    async function gzipToB64(str) {
      if (typeof CompressionStream === "undefined") {
        return null;
      }
      const input = toUtf8Bytes(str);
      const cs = new CompressionStream("gzip");
      const writer = cs.writable.getWriter();
      writer.write(input);
      writer.close();
      const compressedBuffer = await new Response(cs.readable).arrayBuffer();
      let binary = "";
      const bytes = new Uint8Array(compressedBuffer);
      for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    function getHtml() {
      return htmlInput.value.trim();
    }

    function setStatus(msg, kind) {
      statusBox.textContent = msg;
      statusBox.className = "status";
      if (kind) statusBox.classList.add(kind);
    }

    function estimateDispatchPayloadChars(payload) {
      return JSON.stringify(payload).length;
    }

    function inferSurface(html) {
      const t = html.toUpperCase();
      if (/(MOBILE|IPHONE|ANDROID)/.test(t)) return "MOBILE";
      if (/(API|DEVELOPER|DEV\b|TERMINAL|CONSOLE)/.test(t)) return "API/DEV";
      if (/(DESKTOP|MACOS|WINDOWS APP|NATIVE APP)/.test(t)) return "DESKTOP";
      if (/(WEB|DASHBOARD|BROWSER|SAAS)/.test(t)) return "WEB";
      return "WEB (fallback)";
    }

    function runChecks(html) {
      const results = [];
      results.push({
        label: "Required title",
        ok: html.includes("<h1>Interactive iPRD</h1>"),
        detail: "Must include exact <h1>Interactive iPRD</h1>."
      });
      results.push({
        label: "Single-file friendly",
        ok: !/(<script[^>]+src=|<link[^>]+href=)/i.test(html),
        detail: "No external JS/CSS links for offline requirement."
      });
      results.push({
        label: "Full HTML document",
        ok: /<html[\s>]/i.test(html) && /<body[\s>]/i.test(html),
        detail: "Should be complete HTML, not a fragment."
      });
      results.push({
        label: "Size hint",
        ok: html.length < 150000,
        detail: "Large payloads may fail dispatch due to workflow input limits."
      });
      const plainPayload = {
        ref: "main",
        inputs: {
          slug: slugify(slugInput.value || "sample-slug"),
          title: (titleInput.value || "Sample Title").trim(),
          html_base64: toB64(html)
        }
      };
      const estimatedChars = estimateDispatchPayloadChars(plainPayload);
      results.push({
        label: "Dispatch payload estimate",
        ok: estimatedChars < WORKFLOW_INPUT_LIMIT,
        detail: `Plain payload is ~${estimatedChars} chars; workflow_dispatch limit is ${WORKFLOW_INPUT_LIMIT}.`
      });

      checks.innerHTML = "<h2 class=\"section-title\" style=\"margin-top:0;\">Preflight Checks</h2>";
      results.forEach((r) => {
        const row = document.createElement("div");
        row.className = "check-item";
        row.innerHTML = `${r.ok ? "✅" : "⚠️"} <b>${r.label}</b> - ${r.detail}`;
        checks.appendChild(row);
      });

      return results;
    }

    async function buildDispatchPayload(html, slug, title) {
      const plainPayload = {
        ref: "main",
        inputs: {
          slug,
          title,
          html_base64: toB64(html)
        }
      };
      const plainChars = estimateDispatchPayloadChars(plainPayload);
      if (plainChars <= WORKFLOW_INPUT_LIMIT) {
        return { payload: plainPayload, mode: "plain", chars: plainChars };
      }

      const gzipB64 = await gzipToB64(html);
      if (!gzipB64) {
        throw new Error(
          `Payload too large (${plainChars} chars) and gzip compression is unavailable in this browser.`
        );
      }

      const gzipPayload = {
        ref: "main",
        inputs: {
          slug,
          title,
          html_gzip_base64: gzipB64
        }
      };
      const gzipChars = estimateDispatchPayloadChars(gzipPayload);
      if (gzipChars > WORKFLOW_INPUT_LIMIT) {
        throw new Error(
          `Payload too large even after gzip (${gzipChars} chars). Split/simplify HTML before deploy.`
        );
      }

      return { payload: gzipPayload, mode: "gzip", chars: gzipChars, plainChars };
    }

    async function loadRegistry() {
      try {
        const res = await fetch("./iprds/index.json", { cache: "no-store" });
        if (!res.ok) throw new Error("registry not found");
        const data = await res.json();
        cards.innerHTML = "";

        (data.items || []).forEach((item) => {
          const card = document.createElement("div");
          card.className = "card";

          const left = document.createElement("div");
          const link = document.createElement("a");
          link.href = item.path;
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          link.textContent = item.title || item.slug;

          const meta = document.createElement("small");
          meta.textContent = `${item.path} | ${item.slug}`;

          left.appendChild(link);
          left.appendChild(meta);

          const date = document.createElement("small");
          date.textContent = item.updated_at || "";

          card.appendChild(left);
          card.appendChild(date);
          cards.appendChild(card);
        });

        if (!data.items || data.items.length === 0) {
          cards.innerHTML = "<div class=\"status warn\">No deployed pages yet.</div>";
        }
      } catch (error) {
        cards.innerHTML = `<div class="status bad">Registry unavailable: ${error.message}</div>`;
      }
    }

    async function checkLatestRun() {
      const token = tokenInput.value.trim() || localStorage.getItem("iprd_gh_token") || "";
      if (!token) {
        setStatus("Token required to query workflow runs.", "warn");
        return;
      }

      const url = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/runs?event=workflow_dispatch&branch=main&per_page=1`;
      try {
        const res = await fetch(url, {
          headers: {
            "Authorization": `Bearer ${token}`,
            "Accept": "application/vnd.github+json"
          }
        });
        const bodyText = await res.text();
        if (!res.ok) {
          throw new Error(`Run check failed (${res.status}): ${bodyText}`);
        }
        const data = JSON.parse(bodyText);
        const run = (data.workflow_runs || [])[0];
        if (!run) {
          setStatus("No workflow_dispatch runs found yet.", "warn");
          return;
        }

        const msg = [
          `Latest run: #${run.id}`,
          `Status: ${run.status}`,
          `Conclusion: ${run.conclusion || "n/a"}`,
          `URL: ${run.html_url}`
        ].join("\n");
        setStatus(msg, run.conclusion === "success" ? "ok" : "warn");
      } catch (error) {
        setStatus(String(error.message || error), "bad");
      }
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const html = await file.text();
      htmlInput.value = html;
      if (!slugInput.value) slugInput.value = slugify(file.name);
      if (!titleInput.value) titleInput.value = slugInput.value;
      surfaceTag.textContent = `Surface: ${inferSurface(html)}`;
      runChecks(html);
      setStatus("HTML loaded from file.", "ok");
    });

    document.getElementById("refreshRegistry").addEventListener("click", loadRegistry);

    document.getElementById("validateBtn").addEventListener("click", () => {
      const html = getHtml();
      if (!html) {
        setStatus("Paste or upload HTML first.", "warn");
        return;
      }
      const results = runChecks(html);
      const hasBlocking = results.some((r) => r.label !== "Size hint" && !r.ok);
      surfaceTag.textContent = `Surface: ${inferSurface(html)}`;
      setStatus(hasBlocking ? "Validation found issues. Review checks before deploy." : "Validation passed.", hasBlocking ? "warn" : "ok");
    });

    document.getElementById("previewBtn").addEventListener("click", () => {
      const html = getHtml();
      if (!html) {
        setStatus("Paste or upload HTML first.", "warn");
        return;
      }
      previewFrame.srcdoc = html;
      surfaceTag.textContent = `Surface: ${inferSurface(html)}`;
      runChecks(html);
      setStatus("Preview rendered.", "ok");
    });

    document.getElementById("saveToken").addEventListener("click", () => {
      const token = tokenInput.value.trim();
      localStorage.setItem("iprd_gh_token", token);
      setStatus(token ? "Token saved in browser localStorage." : "Empty token saved (cleared).", "ok");
    });

    document.getElementById("clearToken").addEventListener("click", () => {
      localStorage.removeItem("iprd_gh_token");
      tokenInput.value = "";
      setStatus("Token cleared.", "ok");
    });

    document.getElementById("checkRunBtn").addEventListener("click", checkLatestRun);

    document.getElementById("deployBtn").addEventListener("click", async () => {
      const html = getHtml();
      const slug = slugify(slugInput.value || titleInput.value || "");
      const title = (titleInput.value || slug).trim();
      const token = tokenInput.value.trim() || localStorage.getItem("iprd_gh_token") || "";

      if (!html) {
        setStatus("Missing HTML content.", "warn");
        return;
      }
      if (!slug) {
        setStatus("Missing valid slug.", "warn");
        return;
      }
      if (!token) {
        setStatus("Missing GitHub token.", "warn");
        return;
      }

      const results = runChecks(html);
      const hasBlocking = results.some((r) => r.label !== "Size hint" && !r.ok);
      if (hasBlocking) {
        setStatus("Blocked: validation failed. Fix checks first.", "bad");
        return;
      }

      const endpoint = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/${WORKFLOW_FILE}/dispatches`;

      try {
        const dispatchBuild = await buildDispatchPayload(html, slug, title);
        const payload = dispatchBuild.payload;
        const mode = dispatchBuild.mode;
        const chars = dispatchBuild.chars;

        setStatus(
          mode === "gzip"
            ? `Payload exceeds plain limit. Using gzip mode (${chars} chars). Dispatching workflow...`
            : `Using plain mode (${chars} chars). Dispatching workflow...`,
          "warn"
        );

        const res = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${token}`,
            "Accept": "application/vnd.github+json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        const txt = await res.text();
        if (!res.ok) {
          throw new Error(`Dispatch failed (${res.status}): ${txt}`);
        }

        setStatus(
          `Workflow started for ${slug}.\n` +
          `Wait for run completion, then open:\n` +
          `https://rbx-labs.github.io/iPRD/${slug}`,
          "ok"
        );

        setTimeout(loadRegistry, 1500);
      } catch (error) {
        setStatus(String(error.message || error), "bad");
      }
    });

    tokenInput.value = localStorage.getItem("iprd_gh_token") || "";
    loadRegistry();
    checks.innerHTML = "<h2 class='section-title' style='margin-top:0;'>Preflight Checks</h2><div class='check-item'>ℹ️ Upload or paste HTML to run checks.</div>";
  </script>
</body>
</html>
